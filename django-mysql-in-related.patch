Index: db/backends/__init__.py
===================================================================
--- db/backends/__init__.py	(revision 10069)
+++ db/backends/__init__.py	(working copy)
@@ -102,6 +102,7 @@
     # If True, don't use integer foreign keys referring to, e.g., positive
     # integer primary keys.
     related_fields_match_type = False
+    allow_limit_in_in_subquery = True
 
 class BaseDatabaseOperations(object):
     """
Index: db/backends/mysql/base.py
===================================================================
--- db/backends/mysql/base.py	(revision 10069)
+++ db/backends/mysql/base.py	(working copy)
@@ -112,6 +112,7 @@
     update_can_self_select = False
     allows_group_by_pk = True
     related_fields_match_type = True
+    allow_limit_in_in_subquery = False
 
 class DatabaseOperations(BaseDatabaseOperations):
     def date_extract_sql(self, lookup_type, field_name):
Index: db/models/fields/__init__.py
===================================================================
--- db/models/fields/__init__.py	(revision 10069)
+++ db/models/fields/__init__.py	(working copy)
@@ -193,11 +193,39 @@
 
     def get_db_prep_lookup(self, lookup_type, value):
         "Returns field's value prepared for database lookup."
+        def pk_trace(value):
+            # Value may be a primary key, or an object held in a relation.
+            # If it is an object, then we need to get the primary key value for
+            # that object. In certain conditions (especially one-to-one relations),
+            # the primary key may itself be an object - so we need to keep drilling
+            # down until we hit a value that can be used for a comparison.
+            v, field = value, None
+            try:
+                while True:
+                    v, field = getattr(v, v._meta.pk.name), v._meta.pk
+            except AttributeError:
+                pass
+            if field:
+                if lookup_type in ('range', 'in'):
+                    v = [v]
+                v = field.get_db_prep_lookup(lookup_type, v)
+                if isinstance(v, list):
+                    v = v[0]
+            return v
+
         if hasattr(value, 'as_sql') or hasattr(value, '_as_sql'):
             # If the value has a relabel_aliases method, it will need to
             # be invoked before the final SQL is evaluated
             if hasattr(value, 'relabel_aliases'):
                 return value
+            if lookup_type == 'in':
+                query_uses_limit = value.query.high_mark is not None or \
+                    value.query.low_mark
+                if query_uses_limit and \
+                            not connection.features.allow_limit_in_in_subquery:
+                    ret = map(pk_trace, value)
+                    value.value_annotation = bool(ret)
+                    return ret
             if hasattr(value, 'as_sql'):
                 sql, params = value.as_sql()
             else:
Index: db/models/fields/related.py
===================================================================
--- db/models/fields/related.py	(revision 10069)
+++ db/models/fields/related.py	(working copy)
@@ -145,6 +145,14 @@
             # be invoked before the final SQL is evaluated
             if hasattr(value, 'relabel_aliases'):
                 return value
+            if lookup_type == 'in':
+                query_uses_limit = value.query.high_mark is not None or \
+                    value.query.low_mark
+                if query_uses_limit and \
+                            not connection.features.allow_limit_in_in_subquery:
+                    ret = map(pk_trace, value)
+                    value.value_annotation = bool(ret)
+                    return ret
             if hasattr(value, 'as_sql'):
                 sql, params = value.as_sql()
             else:
