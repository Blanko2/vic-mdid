For-upstream: maybe
Website: http://code.djangoproject.com/ticket/10099

diff django/db/backends/__init__.py django/db/backends/__init__.py
--- django/db/backends/__init__.py	2009-01-15 11:06:34.000000000 +0000
+++ django/db/backends/__init__.py	2009-01-29 13:38:50.000000000 +0000
@@ -81,6 +81,7 @@
     # If True, don't use integer foreign keys referring to, e.g., positive
     # integer primary keys.
     related_fields_match_type = False
+    allow_limit_in_in_subquery = True
 
 class BaseDatabaseOperations(object):
     """
diff django/db/backends/mysql/base.py django/db/backends/mysql/base.py
--- django/db/backends/mysql/base.py	2009-01-15 11:06:34.000000000 +0000
+++ django/db/backends/mysql/base.py	2009-01-29 13:39:00.000000000 +0000
@@ -112,6 +112,7 @@
     update_can_self_select = False
     allows_group_by_pk = True
     related_fields_match_type = True
+    allow_limit_in_in_subquery = False
 
 class DatabaseOperations(BaseDatabaseOperations):
     def date_extract_sql(self, lookup_type, field_name):
diff django/db/models/fields/__init__.py django/db/models/fields/__init__.py
--- django/db/models/fields/__init__.py	2009-01-29 10:46:36.000000000 +0000
+++ django/db/models/fields/__init__.py	2009-01-29 13:39:39.000000000 +0000
@@ -193,11 +193,38 @@
 
     def get_db_prep_lookup(self, lookup_type, value):
         "Returns field's value prepared for database lookup."
+        def pk_trace(value):
+            # Value may be a primary key, or an object held in a relation.
+            # If it is an object, then we need to get the primary key value for
+            # that object. In certain conditions (especially one-to-one relations),
+            # the primary key may itself be an object - so we need to keep drilling
+            # down until we hit a value that can be used for a comparison.
+            v, field = value, None
+            try:
+                while True:
+                    v, field = getattr(v, v._meta.pk.name), v._meta.pk
+            except AttributeError:
+                pass
+            if field:
+                if lookup_type in ('range', 'in'):
+                    v = [v]
+                v = field.get_db_prep_lookup(lookup_type, v)
+                if isinstance(v, list):
+                    v = v[0]
+            return v
         if hasattr(value, 'as_sql'):
             # If the value has a relabel_aliases method, it will need to
             # be invoked before the final SQL is evaluated
             if hasattr(value, 'relabel_aliases'):
                 return value
+            if lookup_type == 'in':
+                query_uses_limit = value.query.high_mark is not None or \
+                    value.query.low_mark
+                if query_uses_limit and \
+                            not connection.features.allow_limit_in_in_subquery:
+                    ret = map(pk_trace, value)
+                    value.value_annotation = bool(ret)
+                    return ret
             sql, params = value.as_sql()
             return QueryWrapper(('(%s)' % sql), params)
 
diff django/db/models/fields/related.py django/db/models/fields/related.py
--- django/db/models/fields/related.py	2009-01-29 10:46:36.000000000 +0000
+++ django/db/models/fields/related.py	2009-01-29 13:39:55.000000000 +0000
@@ -145,6 +145,14 @@
             # be invoked before the final SQL is evaluated
             if hasattr(value, 'relabel_aliases'):
                 return value
+            if lookup_type == 'in':
+                query_uses_limit = value.query.high_mark is not None or \
+                    value.query.low_mark
+                if query_uses_limit and \
+                            not connection.features.allow_limit_in_in_subquery:
+                    ret = map(pk_trace, value)
+                    value.value_annotation = bool(ret)
+                    return ret
             sql, params = value.as_sql()
             return QueryWrapper(('(%s)' % sql), params)
 
